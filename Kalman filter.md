# Kalman filter

整理关于kalman滤波有关的内容，毕竟这是一个很经典的滤波器。按照西工大自己的课程内容来整理。

### 最小二乘 | 最小方差

最小方差的部分稍等整理，先来看最小二乘的部分。因为最小二乘法是kalman滤波中的特例，而kalman又是一种最小方差的无偏估计方法。

1. 最小二乘
   - 最小二乘法计算起来比较简单，就是从均方误差来的，推导过程就是找到一个预估向量值，让整个均方误差取最小值。对$(z-H\hat{x})(z-H\hat{x})^T$求导，得出 $\hat{x}$取值
2. 加权最小二乘
   - 在最小二乘的基础上使用了权重(就是对预估向量值的不同分量，给定不同) -> 经过证明之后才能说明





​	通过测量值Z来计算实际的状态向量X，这就是估计。通过使用的估计指标不同，计算出来的x就有所不同。

​	最小二乘估计的对象是一个固定不变的状态向量X，使用的指标就是测量值Z与估计值X的误差要尽可能的小

**最小二乘**是对一个不变的状态向量来进行估计，也就是这个模型中只有观测模型，没有预测模型(这是kalman filter中的一个概念)，可以将模型简单写为Z=HX+V。

​	既然是最小方差估计，那么实际找到一个估计值让其使估计的噪声方差最小。因为已经假设了是白噪声，所以Cov(Z-HX) = E(Z-HX的转置乘以Z-HX)

开始一定是得到了关于状态向量的观测值Z，但是观测值与实际值还是有些区别，这个对应的就是误差。









PS: 无论是最小二乘还是卡尔曼滤波，本质上都是一种估计，提到估计就不得不知道这个估计是不是无偏估计(判断的方式很简单)，就是去判断这个估计量的均值是不是与真实值X相等即可。

参考链接：

1. https://blog.csdn.net/weixin_41558411/article/details/123585534 (关于最小二乘是无偏的证明)

    

    





对于kalman中提到的一些基本概念的补充(不知道这个概念是不是严老师独创的)，后面所提到的所有的变量都是多元的，毕竟kalman很少对一维系统进行分析。

- 协方差矩阵: 这是一个常见的概念，也就是多元变量中方差的拓展表示。这个矩阵中的对角线元素对应的是每一个分量自己的方差，其余部分就是分量与分量之间的协方差——计算方式为$E((x-x^-)(y-y^-))$，整体就是一个大的矩阵。

    - 实际对信号建模的时候，一般都会给出变量自己的协方差矩阵

        

- 均方误差矩阵：**均方误差实际上是真实值与预估值之间的差值的平方的均值**(虽然我不知道为什么对于一个预估值还存在这均值这种概念，从另一个角度来想，估计就是在测量值逐渐变多的情况下，估计量也会收敛到一个值左右，即为均值)。类比于协方差矩阵，对于一个多维变量，均方差误差的计算就可以认为是 $E\left( \left( X-\hat{X} \right) \left( X-\hat{X} \right) ^T \right) $​，有点类似协方差矩阵的计算，计算形式上非常接近，但是统计含义上还是有很大区别的。有些估计方法是将待估计变量所有分量的均方误差之和取最小，也就是将这个均方误差矩阵的迹取最小。而且使用这种矩阵计算而不是直接计算的好处是不是会引入更多的一些信息，即X自己的分量与其他分量之间计算了一个方程，物理意义不明确。

    

- 协均方误差矩阵：基于上述两种矩阵的进一步拓展，表示形式为$E\left( \left( X-\hat{X} \right) \left( Z-\hat{Z} \right) ^T \right) $，上面的均方误差对角线元素就是每一个分量自己与估计的均方误差，现在用协方差的表示来改写这个矩阵。实际上这个矩阵中的每一项都不是之前定义出来的均方误差。可以假设这种说法有一定意义，看看这一项在实际中如何使用的即可。这里与均方误差矩阵中的物理意义还不明确。



为什么量测一步预测用的是状态一步预测的结果来计算的。

![image-20240420001801775](figure/image-20240420001801775.png)







****

## base

最简单的kalman filter肯定是线性方程的kalman。**一般使用kalman的时候，都是从连续方程开始建立，最后离散化成为离散kalman进行处理。连续方程引入的是状态变量的导数(类似于现代控制中的状态方程)**。在slam中对IMU测量方程进行处理的时候，也是先将整个方程从连续转到离散再进行处理——这样会导致噪声的协方差发生变化(感觉是从信号功率的角度做了一个等效)。**kalman实际使用中都应该对于量测与状态方程都进行连续到离散转换。**

- KF中的转换

  <img src="./figure/image-20240506024806436.png" alt="image-20240506024806436" style="zoom:80%;" />

- SLAM连续离散转换

![image-20240506021239906](./figure/image-20240506021239906.png)





顺便给一个kalman的例子。这个题目给出的题干中的状态方程是需要手动转换成离散形式，雷达观测是直接写成了离散形式(均方差的单位有误)

![image-20240506165551785](./figure/image-20240506165551785.png)

- 使用matlab对于信号进行可视化

```matlab
clc;
clear;
close all;
x =zeros(1,1000);
x(1) = 25;
for i = 1:1000-1
    w = normrnd(0,sqrt(0.4))
    x(i+1) = x(i)+ w;
end
% 绘制图像
plot(1:1000, x(1,:));
```

随机运行两次之后，本身一个固定在25的数值由于累计误差的影响，数据值的飘移情况很大。这也说明了如果一个系统只使用状态递推，每一次递推中加入的随机变量(噪声)会让这个系统推向一个未知的位置上，这就是累积误差的作用。就像一个IMU的输出会随着累积误差逐渐离谱，如果这个时候再加入一个量测信息，当前时刻的状态估计就可以有一定的修正。IMU的递推再以这个估计出来的状态进行，这样累积误差就会受到一定的修正。**但是状态递推本身的误差以及量测误差还是包含在最后的估计量中，再往下的分析我就不明白了，不知道什么时候这个误差会让整个系统崩溃。**



![image-20240506024006386](./figure/image-20240506024006386.png)

根据上述题目设置一个滤波器

```matlab
clc;
clear;
close all;
%% 生成运动方程与测量方程
Ts = 0.5;
F = [1,Ts; 0,1];
G = [0;1];
q = 0.1;

Q = q*Ts;
R = 50;
x = zeros(2,400/Ts);
x(:,1) = [-80000;200];
% 生成运动方程
for i = 2:400/Ts   
    w = normrnd(0,sqrt(Q));
    x(:,i)=F*x(:,i-1)+G*w;
end

H = [1,0];
z = zeros(1,400/Ts);
% 测量方程 | 对应的测量方程一定是从真实状态得到的(真实状态也是会受到噪声影响的)
for i = 1:400/Ts
    v =  normrnd(0,R);
    z(i) = H*x(:,i)+v;
end


%% kalman filter

x_kalman = zeros(2,400/Ts);

x_kalman(:,1) = x(:,1);     % 初始状态为真实值
P_pre = [100,0 ; 0,1];      % 这里设置的第一次估计的均方误差
I = eye(2);

for i = 2:400/Ts
    x_temp = F*x_kalman(:,i-1);  % 状态一步预测
    P_temp = F*P_pre*F' + G*Q*G'; 
    K = P_temp*H'*pinv(H*P_temp*H'+R);
    x_kalman(:,i) = x_temp + K*(z(i)-H*x_temp);
    P_pre = (I-K*H)*P_temp;
        
end

% 只进行状态递推(我认为这里是必然要加上噪声信息，不是直接在上一步的kalman滤波中使用x_temp = F*x_kalman(:,i-1) —— 这样推导每一步都是最优估计，但前向传递必然加上噪声！)
x_pure(:,1) = x(:,1);
for i = 2:400/Ts
    w = normrnd(0,sqrt(Q));
    x_pure(:,i) = F*x_pure(:,i-1)+G*w;
end


%% 绘制结果
% 绘制图像 | 对于真实位移的图像就是一条直线 | 计算结果为估计与实际测量误差比测量与实际测量误差 | 黄线为只进行递推得到的误差曲线
figure(1);
plot(1:400/Ts, x(1,:)-x_kalman(1,:),'-b'); hold on;
plot(1:400/Ts, x(1,:)-x_pure(1,:),'-g'); hold on;
plot(1:400/Ts, x(1,:)-z,'-r');

```

出来的结果比较 真实值 | KF估计值 | 纯递推估计值 | 测量值 之间的区别

![image-20240506170845833](./figure/image-20240506170845833.png)





